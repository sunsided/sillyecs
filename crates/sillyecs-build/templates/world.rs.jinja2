/// A command in the [`World`].
#[allow(dead_code)]
pub enum WorldCommand<UserCommand> {
    /// Spawn an entity.
    ///
    /// # Note:
    /// Due to the reusability of systems, not all commands are valid in all worlds.
    SpawnEntity(ArchetypeEntityData),
    /// Despawn an entity.
    DespawnEntity(::sillyecs::EntityId),
    /// A user-specific command.
    User(UserCommand)
}

pub trait WorldUserCommand {
    type UserCommand: core::marker::Send + core::fmt::Debug;
}

/// Sender of [`WorldCommand`] instances.
#[allow(dead_code)]
pub trait WorldCommandSender: WorldUserCommand {
    type Error: core::error::Error;

    /// Sends a command. May block until sending is complete.
    fn send(&self, command: WorldCommand<Self::UserCommand>) -> Result<(), Self::Error>;
}

/// Sender of [`WorldCommand`] instances.
#[allow(dead_code)]
pub trait WorldCommandReceiver: WorldUserCommand {
    type Error: core::error::Error;

    /// Attempts to receive a message from the channel without blocking.
    /// Returns [`Ok(None)`] if no command was queued.
    fn recv(&self) -> Result<Option<WorldCommand<Self::UserCommand>>, Self::Error>;
}

/// Handler of a [`WorldCommand`]'s user command.
#[allow(dead_code)]
pub trait WorldUserCommandHandler: WorldUserCommand {
    /// Handles a user command.
    fn handle_user_command(&mut self, command: Self::UserCommand);
}

/// A sender and receiver of [`WorldCommand`] instances.
#[allow(dead_code)]
pub trait WorldCommandQueue: WorldCommandSender + WorldCommandReceiver { }

impl<T, U> WorldCommandQueue for T
where
    T: WorldCommandSender<UserCommand = U> + WorldCommandReceiver<UserCommand = U>
{ }

{%- if ecs.any_phase_on_request %}

/// Spawns an entity into the world.
#[derive(Debug, Default)]
struct ConditionalPhaseFlags {
    {%- for phase in ecs.phases %}
    {%- if phase.on_request %}
    /// Whether the [`{{ phase.name.raw }}`]({{ phase.name.type }}) phase is requested.
    pub {{ phase.name.field }}_requested: core::sync::atomic::AtomicBool,
    {%- endif %}
    {%- endfor %}
}

impl ConditionalPhaseFlags {
    {%- for phase in ecs.phases %}
    {%- if phase.on_request %}
    /// Returns whether the [`{{ phase.name.raw }}`]({{ phase.name.type }}) phase was requested
    /// and atomically sets the flag to `false`.
    #[inline]
    pub fn is_{{ phase.name.field }}_requested(&self) -> bool {
        self.{{ phase.name.field }}_requested.swap(false, core::sync::atomic::Ordering::AcqRel)
    }

    /// Sets the request status of the [`{{ phase.name.raw }}`]({{ phase.name.type }}) phase.
    #[inline]
    pub fn set_{{ phase.name.field }}_requested(&self) {
        self.{{ phase.name.field }}_requested
            .store(true, core::sync::atomic::Ordering::Release);
    }
    {%- endif %}
    {%- endfor %}
}

impl Clone for ConditionalPhaseFlags {
    fn clone(&self) -> Self {
        Self {
            {%- for phase in ecs.phases %}
            {%- if phase.on_request %}
            {{ phase.name.field }}_requested: core::sync::atomic::AtomicBool::new(
                self.{{ phase.name.field }}_requested.load(core::sync::atomic::Ordering::Acquire),
            ),
            {%- endif %}
            {%- endfor %}
        }
    }
}
{%- endif %}
{% for world in ecs.worlds %}

/// A world  all archetypes.
#[derive(Debug)]
pub struct {{ world.name.type }}<E, Q> {
    /// The archetypes.
    archetypes: {{ world.name.type }}Archetypes,
    /// The systems.
    pub systems: {{ world.name.type }}Systems,
    {%- if ecs.any_phase_on_request %}
    /// Flags for conditional phase execution.
    phase_flags: ConditionalPhaseFlags,
    {%- endif %}
    /// The frame context.
    context: ::sillyecs::FrameContext,
    {%- if ecs.any_phase_fixed %}
    /// The fixed-time accumulators.
    fixed_accumulators: FixedAccumulators,
    {%- endif %}
    /// The phase delta times.
    delta_timers: DeltaTimers,
    /// The system phase events
    events: E,
    {%- if (world.states | length) > 0 %}
    /// User-specific data.
    pub states: {{ world.name.type }}States,
    {%- endif %}
    command_queue: Q
}

impl<E, Q> ::sillyecs::World for {{ world.name.type }}<E, Q> {
    const ID: ::sillyecs::WorldId = ::sillyecs::WorldId::new_from(core::num::NonZeroU64::new({{ world.id }}).expect("Invalid ID on ECS construction time"));
}
{%- if (world.states | length) > 0 %}

/// The user states used in the world.
///
/// It encapsulates ownership of and access to the following state types:
/// {% for state in world.states %}
/// - [{{ state.name.type }}]({{ state.name.type }}){%- endfor %}
#[derive(Debug, Default)]
pub struct {{ world.name.type }}States {
    {%- for state in world.states %}
    {%- if state.description %}
    /// {{ state.description }}
    {%- else %}
    /// A user-defined state.
    {%- endif %}
    ///
    /// The state is used in the following systems:
    {%- for system in state.systems %}
    /// - [`{{system.type}}`]
    {%- endfor %}
    pub {{ state.name.field }}: {{ state.name.type }},
    {%- endfor %}
}

#[allow(dead_code)]
impl {{ world.name.type }}States {
    pub const fn new(
        {%- for state in world.states %}
        {{ state.name.field }}: {{ state.name.type }},
        {%- endfor %}
    ) -> Self {
        Self {
            {%- for state in world.states %}
            {{ state.name.field }},
            {%- endfor %}
        }
    }
}


{%- endif %}

/// The archetypes used in the world.
#[derive(Debug, Clone, Default)]
struct {{ world.name.type }}Archetypes {
    /// The entity locator.
    //
    // Hashmap type not provided by design. Provide your own implementation such as fxhash::FxHashMap via type alias.
    // Example:
    //      type EntityLocationMap<K, V> = fxhash::FxHashMap<K, V>;
    //
    entity_locations: EntityLocationMap<::sillyecs::EntityId, EntityArchetypeRef>,

    pub collection: {{ world.name.type }}ArchetypeCollection
}

/// The archetypes used in the world.
#[derive(Debug, Clone, Default)]
struct {{ world.name.type }}ArchetypeCollection {
    {%- for archetype in ecs.archetypes %}
    pub {{ archetype.name.field | snake_case }}: {{ archetype.name.type }},
    {%- endfor %}
}

/// The systems.
#[derive(Debug)]
pub struct {{ world.name.type }}Systems {
    {%- for system in world.systems %}
    {{ system.name.field }}: {{ system.name.type }},
    {%- endfor %}
}

impl {{ world.name.type }}Systems {
    {%- for system in world.systems %}

    /// Gives immutable access to the [`{{ system.name.type }}Data`] of the [`{{ system.name.type }}`].
    #[inline]
    pub fn as_{{ system.name.field }}_ref(&self) -> &{{ system.name.type }}Data {
        use core::ops::Deref;
        self.{{ system.name.field }}.deref()
    }

    /// Gives mutable access to the [`{{ system.name.type }}Data`] of the [`{{ system.name.type }}`].
    #[inline]
    pub fn as_{{ system.name.field }}_mut(&mut self) -> &mut {{ system.name.type }}Data {
        use core::ops::DerefMut;
        self.{{ system.name.field }}.deref_mut()
    }
    {%- endfor %}
}
{%- for system in world.systems %}

impl AsRef<{{ system.name.type }}Data> for {{ world.name.type }}Systems {
    #[inline]
    fn as_ref(&self) -> &{{ system.name.type }}Data {
        self.as_{{ system.name.field }}_ref()
    }
}

impl AsMut<{{ system.name.type }}Data> for {{ world.name.type }}Systems {
    #[inline]
    fn as_mut(&mut self) -> &mut {{ system.name.type }}Data {
        self.as_{{ system.name.field }}_mut()
    }
}
{%- endfor %}
{%- for archetype in world.archetypes %}

/// Spawns an entity into the world.
impl<E, Q> Spawn<{{ archetype.name.raw }}EntityData> for {{ world.name.type }}<E, Q> {
    /// Spawn a new entity into the world.
    #[inline]
    fn spawn(&mut self, data: {{ archetype.name.raw }}EntityData) -> ::sillyecs::EntityId {
        self.spawn_{{ archetype.name.field}}(data)
    }
}

/// Spawns an entity into the world.
impl<E, Q> Spawn<{{ archetype.name.raw }}EntityComponents> for {{ world.name.type }}<E, Q> {
    /// Spawn a new entity into the world.
    #[inline]
    fn spawn(&mut self, data: {{ archetype.name.raw }}EntityComponents) -> ::sillyecs::EntityId {
        self.spawn_{{ archetype.name.field}}(data)
    }
}
{%- endfor %}

/// Helper trait to prevent accidental abuse of the Archetype's spawning function.
pub trait WorldEntityRegistry {
    /// Registers an entity with the world.
    fn register(&mut self, id: ::sillyecs::EntityId, archetype: EntityArchetypeRef) -> ::sillyecs::EntityId;
}

#[allow(dead_code)]
impl<Q> {{ world.name.type }}<NoOpPhaseEvents, Q> {
    /// Creates a new [`{{ world.name.type }}`].
    pub fn new<S>(
        create_systems: &S,
        {%- if (world.states | length) > 0 %}
        states: {{ world.name.type }}States,
        {%- endif %}
        command_queue: Q) -> Self
    where
        S: CreateSystems,
        Q: WorldCommandQueue
    {
        Self::new_with_events(
            create_systems,
            {%- if (world.states | length) > 0 %}
            states,
            {%- endif %}
            command_queue,
            NoOpPhaseEvents
        )
    }
}

#[allow(dead_code)]
impl<E, Q> {{ world.name.type }}<E, Q> {
    /// Creates a new [`{{ world.name.type }}`].
    pub fn new_with_events<S>(
        create_systems: &S,
        {%- if (world.states | length) > 0 %}
        states: {{ world.name.type }}States,
        {%- endif %}
        command_queue: Q,
        phase_events: E) -> Self
    where
        {% set systemLoopCount = 0 -%}
        S: {% for system in world.systems %}{% set systemLoopCount = systemLoopCount + 1 %}{% if systemLoopCount > 1 %}
         + {% endif %}CreateSystem<{{ system.name.type }}>{% endfor -%},
        E: SystemPhaseEvents,
        Q: WorldCommandQueue
    {
        let context = ::sillyecs::FrameContext::new(<Self as ::sillyecs::World>::ID);
        Self {
            archetypes: Default::default(),
            systems: {{ world.name.type }}Systems {
                {%- for system in world.systems %}
                {{ system.name.field }}: CreateSystem::<{{ system.name.type }}>::create(create_systems),
                {%- endfor %}
            },
            {%- if ecs.any_phase_on_request %}
            phase_flags: ConditionalPhaseFlags::default(),
            {%- endif %}
            context,
            {%- if (world.states | length) > 0 %}
            states,
            {%- endif %}
            {%- if ecs.any_phase_fixed %}
            fixed_accumulators: Default::default(),
            {%- endif %}
            delta_timers: DeltaTimers::default(),
            events: phase_events,
            command_queue
        }
    }

    /// Resets the frame context, e.g. after the application comes back from background.
    pub fn reset_frame_context(&mut self) {
        self.context.reset();
    }

    /// Returns the overall number of entities in this world.
    pub fn len(&self) -> usize {
        self.archetypes.entity_locations.len()
    }

    /// Indicates whether there are no entities in this world.
    pub fn is_empty(&self) -> bool {
        self.archetypes.entity_locations.is_empty()
    }

    /// De-spawns an entity given by its [`::sillyecs::EntityId`]. Returns an error if the entity was unknown in this world.
    pub fn despawn_by_id(&mut self, id: ::sillyecs::EntityId) -> Result<(), DespawnError> {
        self.handle_despawn_command(id)
    }
    {%- for phase in ecs.phases %}
    {%- if phase.on_request %}

    /// Requests the execution of the [`{{ phase.name.raw }}`]({{ phase.name.type }}) phase.
    #[inline]
    pub fn request_{{ phase.name.field }}_phase(&self) {
        self.phase_flags.set_{{ phase.name.field }}_requested();
    }
    {%- endif %}
    {%- endfor %}
    {%- for archetype in world.archetypes %}

    /// Spawn a new `{{ archetype.name.raw }}` entity into the world given its [`{{ archetype.name.raw }}EntityData`].
    #[inline]
    pub fn spawn_{{ archetype.name.field }}<Entity>(
        &mut self,
        {{ archetype.name.field }}: Entity
    ) -> ::sillyecs::EntityId
    where
        Entity: Into<{{ archetype.name.raw }}EntityComponents>
    {
        let {{ archetype.name.field }} = {{ archetype.name.field }}.into();
        self.spawn_{{ archetype.name.field }}_with(
            {%- for component_name in archetype.components %}
            {{ archetype.name.field }}.{{component_name.field}},
            {%- endfor %}
        )
    }

    /// Spawn a new `{{ archetype.name.raw }}` entity into the world.
    pub fn spawn_{{ archetype.name.field }}_with(
        &mut self,
        {%- for component_name in archetype.components %}
        {{component_name.field}}: {{ component_name.type }},
        {%- endfor %}
    ) -> ::sillyecs::EntityId {
        struct Registry<'a>(&'a mut EntityLocationMap<::sillyecs::EntityId, EntityArchetypeRef>);

        impl WorldEntityRegistry for Registry<'_> {
            #[inline(always)]
            fn register(&mut self, id: ::sillyecs::EntityId, archetype: EntityArchetypeRef) -> ::sillyecs::EntityId {
                self.0.insert(id, archetype);
                id
            }
        }

        let registry = Registry(&mut self.archetypes.entity_locations);
        self.archetypes
            .collection
            .{{ archetype.name.field }}
            .spawn_with(
                {%- for component_name in archetype.components %}
                {{component_name.field}},
                {%- endfor %}
                registry
            )
    }
    {%- endfor %}

    /// Runs a per-frame update of the frame context at the start of a frame.
    fn on_begin_frame(&mut self) {
        self.context.current_frame_start = std::time::Instant::now();
        if self.context.frame_number == 0 {
            self.context.delta_time_secs = 0.0;
        } else {
            self.context.delta_time_secs = (self.context.current_frame_start - self.context.last_frame_start).as_secs_f32();
        }
        self.context.frame_number = self.context.frame_number.wrapping_add(1);
    }

    /// Runs a per-frame update of the frame context at the end of a frame.
    fn on_end_frame(&mut self) {
        self.context.last_frame_start = self.context.current_frame_start;
    }
    {%- for phase in ecs.phases %}

    /// Runs a per-frame update of the frame context at the start of a frame.
    fn on_begin_{{ phase.name.field }}_phase(&mut self) {
        let now = std::time::Instant::now();
        let previous = self.delta_timers.previous_{{ phase.name.field }}_start;
        self.delta_timers.current_{{ phase.name.field }}_start = now;
        self.context.current_frame_start = now;
        self.context.last_frame_start = previous;
        if self.context.frame_number == 0 {
            self.context.delta_time_secs = 0.0;
        } else {
            self.context.delta_time_secs = (now - previous).as_secs_f32();
        }
    }

    /// Runs a per-frame update of the frame context at the end of a frame.
    fn on_end_{{ phase.name.field }}_phase(&mut self) {
        self.delta_timers.previous_{{ phase.name.field }}_start = self.delta_timers.current_{{ phase.name.field }}_start;
    }
    {%- endfor %}

    /// Apply all system phases sequentially.
    ///
    /// This method executes all system phases in sequence.
    /// The phases are processed in the following order:
    ///
    /// {% for phase in ecs.phases %}- {% if phase.manual %}~~`{{ phase.name.raw }}`~~ (skipped here, must be executed manually){% else %}`{{ phase.name.raw }}`{% endif %}
    /// {% endfor %}
    /// # Type Parameters
    /// - `E`: The type implementing [`SystemPhaseEvents`] for phase lifecycle events
    pub fn apply_system_phases(&mut self)
    where
        E: SystemPhaseEvents,
        Q: WorldCommandSender + WorldCommandReceiver
    {
        self.on_begin_frame();
        self.handle_commands();

        {%- for phase in ecs.phases %}
        {%- if phase.manual %}

        // NOTE: The {{ phase.name.raw }} phase is marked manual and will be skipped here.
        //       self.par_apply_system_phase_{{ phase.name.field }}();
        {%- else %}
        {%- if not phase.fixed %}
        {%- if phase.on_request %}

        // The {{ phase.name.raw }} phase is conditional.
        if self.phase_flags.is_{{ phase.name.field }}_requested() {
            self.apply_system_phase_{{ phase.name.field }}();
        }
        {%- else %}
        // The {{ phase.name.raw }} phase always runs.
        self.apply_system_phase_{{ phase.name.field }}();
        {%- endif %}
        {%- else %}
        {%- if phase.on_request %}

        // The {{ phase.name.raw }} phase is conditional.
        if self.phase_flags.is_{{ phase.name.field }}_requested() {
            // Apply fixed-time loop for phase {{ phase.name.raw }}
            self.context.fixed_time_secs = SystemPhase::{{ phase.name.field | upper }}_SECS;
            self.fixed_accumulators.{{ phase.name.field }} += self.context.delta_time_secs;
            while self.fixed_accumulators.{{ phase.name.field }} >= SystemPhase::{{ phase.name.field | upper }}_SECS {
                self.apply_system_phase_{{ phase.name.field }}();
                self.fixed_accumulators.{{ phase.name.field }} -= SystemPhase::{{ phase.name.field | upper }}_SECS;
            }
        }
        {%- else %}

        // Apply fixed-time loop for phase {{ phase.name.raw }}
        self.context.fixed_time_secs = SystemPhase::{{ phase.name.field | upper }}_SECS;
        self.fixed_accumulators.{{ phase.name.field }} += self.context.delta_time_secs;
        while self.fixed_accumulators.{{ phase.name.field }} >= SystemPhase::{{ phase.name.field | upper }}_SECS {
            self.apply_system_phase_{{ phase.name.field }}();
            self.fixed_accumulators.{{ phase.name.field }} -= SystemPhase::{{ phase.name.field | upper }}_SECS;
        }
        {%- endif %}
        self.context.fixed_time_secs = 0.0;
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        self.on_end_frame();
        self.handle_commands();
    }

    /// Apply all system phases with thread parallelism.
    ///
    /// This method executes all system phases in sequence, but with parallel execution
    /// of systems within each phase. The phases are processed in the following order:
    ///
    /// {% for phase in ecs.phases %}- {% if phase.manual %}~~`{{ phase.name.raw }}`~~ (skipped here, must be executed manually){% else %}`{{ phase.name.raw }}`{% endif %}
    /// {% endfor %}
    /// # Type Parameters
    /// - `E`: The type implementing [`SystemPhaseEvents`] for phase lifecycle events
    ///
    /// # Parallelism
    /// - Each phase is processed sequentially
    /// - Within each phase, systems are executed in parallel where possible
    /// - Thread parallelism is implemented using the Rayon library
    pub fn par_apply_system_phases(&mut self)
    where
        E: SystemPhaseEvents,
        Q: WorldCommandSender + WorldCommandReceiver
    {
        self.on_begin_frame();
        self.handle_commands();

        {%- for phase in ecs.phases %}
        {%- if phase.manual %}

        // NOTE: The {{ phase.name.raw }} phase is marked manual and will be skipped here.
        //       self.par_apply_system_phase_{{ phase.name.field }}();
        {%- else %}
        {%- if not phase.fixed %}
        {%- if phase.on_request %}

        // The {{ phase.name.raw }} phase is conditional.
        if self.phase_flags.is_{{ phase.name.field }}_requested() {
            self.apply_system_phase_{{ phase.name.field }}();
        }
        {%- else %}
        // The {{ phase.name.raw }} phase always runs.
        self.apply_system_phase_{{ phase.name.field }}();
        {%- endif %}
        {%- else %}
        {%- if phase.on_request %}

        // The {{ phase.name.raw }} phase is conditional.
        if self.phase_flags.is_{{ phase.name.field }}_requested() {
            // Apply fixed-time loop for phase {{ phase.name.raw }}
            self.context.fixed_time_secs = SystemPhase::{{ phase.name.field | upper }}_SECS;
            self.fixed_accumulators.{{ phase.name.field }} += self.context.delta_time_secs;
            while self.fixed_accumulators.{{ phase.name.field }} >= SystemPhase::{{ phase.name.field | upper }}_SECS {
                self.apply_system_phase_{{ phase.name.field }}();
                self.fixed_accumulators.{{ phase.name.field }} -= SystemPhase::{{ phase.name.field | upper }}_SECS;
            }
        }
        {%- else %}

        // Apply fixed-time loop for phase {{ phase.name.raw }}
        self.context.fixed_time_secs = SystemPhase::{{ phase.name.field | upper }}_SECS;
        self.fixed_accumulators.{{ phase.name.field }} += self.context.delta_time_secs;
        while self.fixed_accumulators.{{ phase.name.field }} >= SystemPhase::{{ phase.name.field | upper }}_SECS {
            self.apply_system_phase_{{ phase.name.field }}();
            self.fixed_accumulators.{{ phase.name.field }} -= SystemPhase::{{ phase.name.field | upper }}_SECS;
        }
        {%- endif %}
        self.context.fixed_time_secs = 0.0;
        {%- endif %}
        {%- endif %}
        {%- endfor %}
        self.on_end_frame();
        self.handle_commands();
    }
    {%- for phase in ecs.phases %}

    /// Execute system phase `{{ phase.name.raw }}`
    ///
    /// This method executes all systems scheduled for the `{{ phase.name.raw }}` phase in sequential order.
    /// Systems are organized into groups that must be executed in sequence, while systems within each
    /// group can potentially be parallelized (see `par_apply_system_phase_{{ phase.name.field }}`).
    ///
    /// # Execution Flow
    /// 1. Triggers the phase start event if event handling is enabled
    /// 2. Sequentially processes each system group
    /// 3. For each system in a group:
    ///    - Applies the system to all matching archetypes
    ///    - Provides read-only access to input components
    ///    - Provides mutable access to output components
    /// 4. Triggers the phase end event if event handling is enabled
    ///
    /// # Type Parameters
    /// - `E`: The type implementing `SystemPhaseEvents` for phase lifecycle events
    {% if phase.manual -%}pub {% endif -%}
    fn apply_system_phase_{{ phase.name.field }}(&mut self)
    where
        E: SystemPhaseEvents,
        Q: WorldCommandSender + WorldCommandReceiver
    {
        self.on_begin_{{ phase.name.field }}_phase();
        let result = System{{ phase.name.type }}Events::on_begin_phase(
            &mut self.events,
            &self.context,
            {%- for state in phase.states %}
                {%- set access = state.begin_phase | default(value="none") %}
                {%- if access == "none" %}
                    {# skip #}
                {%- elif access == "read" %}
                    &self.states.{{ state.use.field }},
                {%- elif access == "write" %}
                    &mut self.states.{{ state.use.field }},
                {%- else %}
                    todo!("Invalid state use in ECS construction"),
                {%- endif %}
            {%- endfor %}
        )
        .inspect_err(|error| tracing::error!(%error, "Failed to handle phase begin events"))
        .ok();

        self.apply_system_phase_{{ phase.name.field }}_without_events();

        System{{ phase.name.type }}Events::on_end_phase(
            &mut self.events,
            result,
            &self.context,
            {%- for state in phase.states %}
                {%- set access = state.end_phase | default(value="none") %}
                {%- if access == "none" %}
                    {# skip #}
                {%- elif access == "read" %}
                    &self.states.{{ state.use.field }},
                {%- elif access == "write" %}
                    &mut self.states.{{ state.use.field }},
                {%- else %}
                    todo!("Invalid state use in ECS construction"),
                {%- endif %}
            {%- endfor %}
        )
        .inspect_err(|error| tracing::error!(%error, "Failed to handle phase end events"))
        .ok();

        // Process all commands.
        self.handle_commands();
        self.on_end_{{ phase.name.field }}_phase();
    }

    /// Execute system phase `{{ phase.name.raw }}` without calling events. See [`apply_system_phase_{{ phase.name.field }}`](Self::apply_system_phase_{{ phase.name.field }}).
    #[inline]
    fn apply_system_phase_{{ phase.name.field }}_without_events(&mut self)
    where
        E: SystemPhaseEvents,
        Q: WorldCommandSender + WorldCommandReceiver
    {
        {%- if world.scheduled_systems[phase.name] | length == 0 %}
        // no systems in this phase
        {%- else %}
        {%- for group in world.scheduled_systems[phase.name] %}
        {%- set group_number = loop.index %}
        {%- for system in group %}
        // System group {{ group_number }} of {{ world.scheduled_systems[phase.name] | length }}
        let is_ready = self.systems.{{ system.name.field }}.is_ready(
               {%- if system.needs_context %}
               &self.context,
               {%- endif %}
               {%- for state in system.states %}
                   {%- set access = state.check | default(value="none") %}
                   {%- if access == "none" %}
                       {# skip #}
                   {%- elif access == "read" %}
                       &self.states.{{ state.use.field }},
                   {%- elif access == "write" %}
                       &mut self.states.{{ state.use.field }},
                   {%- else %}
                       todo!("Invalid state use in ECS construction"),
                   {%- endif %}
               {%- endfor %}
           );
        if is_ready && self.systems.{{ system.name.field }}.on_begin_phase(
                {%- if system.needs_context %}
                &self.context,
                {%- endif %}
                {%- for state in system.states %}
                    {%- set access = state.begin_phase | default(value="none") %}
                    {%- if access == "none" %}
                        {# skip #}
                    {%- elif access == "read" %}
                        &self.states.{{ state.use.field }},
                    {%- elif access == "write" %}
                        &mut self.states.{{ state.use.field }},
                    {%- else %}
                        todo!("Invalid state use in ECS construction"),
                    {%- endif %}
                {%- endfor %}
            )
            .inspect_err(|error| tracing::error!(?error, "{{ system.name.type }}::on_begin_phase returned an error"))
            .is_ok()
        {
            // Preflight
            {
                {%- if system.preflight %}
                {%- for archetype in system.affected_archetypes %}
                // Preflight of {{ system.name.type }} for {{ archetype.type }}
                self.systems.{{ system.name.field }}.preflight(
                    {%- if system.needs_context %}
                    &self.context,
                    {%- endif %}
                    {%- if (system.lookup | count) > 0 %}
                    Box::new(&self.archetypes),
                    {%- endif -%}
                    {%- for state in system.states %}
                        {%- set access = state.preflight | default(value="none") %}
                        {%- if access == "none" %}
                            {# skip #}
                        {%- elif access == "read" %}
                            &self.states.{{ state.use.field }},
                        {%- elif access == "write" %}
                            &mut self.states.{{ state.use.field }},
                        {%- else %}
                            todo!("Invalid state use in ECS construction"),
                        {%- endif %}
                    {%- endfor %}
                    {%- if system.needs_entities %}
                    &self.archetypes.collection.{{ archetype.field }}.entities,
                    {%- endif %}
                    {%- for input in system.inputs %}
                    &self.archetypes.collection.{{ archetype.field }}.{{ input.fields }},
                    {%- endfor %}
                    {%- for output in system.outputs %}
                    &self.archetypes.collection.{{ archetype.field }}.{{ output.fields }},
                    {%- endfor %}
                    {%- if system.emits_commands %}
                    &self.command_queue
                    {%- endif %}
                );
                {%- endfor %}
                {%- else %}
                // System has no preflight step
                {%- endif %}
            }

            // Systems
            {
                {%- if system.needs_entities %}
                let entities: [&[::sillyecs::EntityId]; {{ system.affected_archetypes | length }}] = [
                    {%- for archetype in system.affected_archetypes %}
                    &self.archetypes.collection.{{ archetype.field }}.entities,
                    {%- endfor %}
                ];
                {%- endif %}
                {%- for input in system.inputs %}
                let {{ input.field }}_inputs: [&[{{ input.type }}]; {{ system.affected_archetypes | length }}] = [
                    {%- for archetype in system.affected_archetypes %}
                    &self.archetypes.collection.{{ archetype.field }}.{{ input.fields }},
                    {%- endfor %}
                ];
                {%- endfor %}
                {%- for output in system.outputs %}
                let {{ output.field }}_outputs: [&mut [{{ output.type }}]; {{ system.affected_archetypes | length }}] = [
                    {%- for archetype in system.affected_archetypes %}
                    &mut self.archetypes.collection.{{ archetype.field }}.{{ output.fields }},
                    {%- endfor %}
                ];
                {%- endfor %}

                // Apply {{ system.name.type }} to all archetypes
                self.systems.{{ system.name.field }}.apply_all(
                    {%- if system.needs_context %}
                    &self.context,
                    {%- endif %}
                    {%- for state in system.states %}
                        {%- set access = state.system | default(value="none") %}
                        {%- if access == "none" %}
                            {# skip #}
                        {%- elif access == "read" %}
                            &self.states.{{ state.use.field }},
                        {%- elif access == "write" %}
                            &mut self.states.{{ state.use.field }},
                        {%- else %}
                            todo!("Invalid state use in ECS construction"),
                        {%- endif %}
                    {%- endfor %}
                    {%- if system.needs_entities %}
                    entities,
                    {%- endif %}
                    {%- for input in system.inputs %}
                    {{ input.field }}_inputs,
                    {%- endfor %}
                    {%- for output in system.outputs %}
                    {{ output.field }}_outputs,
                    {%- endfor %}
                    {%- if system.emits_commands %}
                    &self.command_queue
                    {%- endif %}
                );
            }

            // Postflight
            {
                {%- if system.postflight %}
                {%- for archetype in system.affected_archetypes %}
                // Postflight of {{ system.name.type }} for {{ archetype.type }}
                self.systems.{{ system.name.field }}.postflight(
                    {%- if system.needs_context %}
                    &self.context,
                    {%- endif %}
                    {%- if (system.lookup | count) > 0 %}
                    Box::new(&self.archetypes),
                    {%- endif -%}
                    {%- for state in system.states %}
                        {%- set access = state.postflight | default(value="none") %}
                        {%- if access == "none" %}
                            {# skip #}
                        {%- elif access == "read" %}
                            &self.states.{{ state.use.field }},
                        {%- elif access == "write" %}
                            &mut self.states.{{ state.use.field }},
                        {%- else %}
                            todo!("Invalid state use in ECS construction"),
                        {%- endif %}
                    {%- endfor %}
                    {%- if system.needs_entities %}
                    &self.archetypes.collection.{{ archetype.field }}.entities,
                    {%- endif %}
                    {%- for input in system.inputs %}
                    &self.archetypes.collection.{{ archetype.field }}.{{ input.fields }},
                    {%- endfor %}
                    {%- for output in system.outputs %}
                    &self.archetypes.collection.{{ archetype.field }}.{{ output.fields }},
                    {%- endfor %}
                    {%- if system.emits_commands %}
                    &self.command_queue
                    {%- endif %}
                );
                {%- endfor %}
                {%- else %}
                // System has no preflight step
                {%- endif %}
            }

            self.systems.{{ system.name.field }}.on_end_phase(
                {%- if system.needs_context %}
                &self.context,
                {%- endif %}
                {%- for state in system.states %}
                    {%- set access = state.end_phase | default(value="none") %}
                    {%- if access == "none" %}
                        {# skip #}
                    {%- elif access == "read" %}
                        &self.states.{{ state.use.field }},
                    {%- elif access == "write" %}
                        &mut self.states.{{ state.use.field }},
                    {%- else %}
                        todo!("Invalid state use in ECS construction"),
                    {%- endif %}
                {%- endfor %}
            )
            .inspect_err(|error| tracing::error!(?error, "{{ system.name.type }}::on_end_phase returned an error"))
            .ok();
        }
        {%- endfor %}
        {%- endfor %}
        {%- endif %}

        // Process all commands.
        self.handle_commands();
    }

    /// Applies the specified system phase with parallel execution of systems.
    ///
    /// This method uses Rayon's parallel scoping to execute systems concurrently within each system
    /// group. Systems within a group are executed in parallel while groups themselves are processed
    /// sequentially.
    ///
    /// # Type Parameters
    /// - `E`: The type implementing `SystemPhaseEvents` for phase lifecycle events
    ///
    /// # Notes
    /// - Systems in each group are spawned as parallel tasks
    /// - Each system operates on its affected archetypes concurrently
    /// - Phase events are triggered at the start and end of execution
    {% if phase.manual -%}pub {% endif -%}
    fn par_apply_system_phase_{{ phase.name.field }}(&mut self)
    where
        E: SystemPhaseEvents,
        Q: WorldCommandSender + WorldCommandReceiver
    {
        self.on_begin_{{ phase.name.field }}_phase();
        let result = System{{ phase.name.type }}Events::on_begin_phase(
            &mut self.events,
            &self.context,
            {%- for state in phase.states %}
                {%- set access = state.begin_phase | default(value="none") %}
                {%- if access == "none" %}
                    {# skip #}
                {%- elif access == "read" %}
                    &self.states.{{ state.use.field }},
                {%- elif access == "write" %}
                    &mut self.states.{{ state.use.field }},
                {%- else %}
                    todo!("Invalid state use in ECS construction"),
                {%- endif %}
            {%- endfor %}
        )
        .inspect_err(|error| tracing::error!(%error, "Failed to handle phase begin events"))
        .ok();

        {%- if world.scheduled_systems[phase.name] | length == 0 %}
        // no systems in this phase
        {%- elif world.scheduled_systems[phase.name] | length == 1 %}
        // Only one system in this phase; skip spawning thread.
        self.apply_system_phase_{{ phase.name.field }}_without_events();
        {%- else %}
        {%- for group in world.scheduled_systems[phase.name] %}
        {%- set group_number = loop.index %}

        // System group {{ group_number }}
        {%- for system in group %}
        let is_{{ system.name.field }}_ready = self.systems.{{ system.name.field }}.is_ready(
               {%- if system.needs_context %}
               &self.context,
               {%- endif %}
               {%- for state in system.states %}
                   {%- set access = state.check | default(value="none") %}
                   {%- if access == "none" %}
                       {# skip #}
                   {%- elif access == "read" %}
                       &self.states.{{ state.use.field }},
                   {%- elif access == "write" %}
                       &mut self.states.{{ state.use.field }},
                   {%- else %}
                       todo!("Invalid state use in ECS construction"),
                   {%- endif %}
               {%- endfor %}
           );
        let is_{{ system.name.field }}_ready = is_{{ system.name.field }}_ready &
            self.systems.{{ system.name.field }}.on_begin_phase(
                {%- if system.needs_context %}
                &self.context,
                {%- endif %}
                {%- for state in system.states %}
                    {%- set access = state.begin_phase | default(value="none") %}
                    {%- if access == "none" %}
                        {# skip #}
                    {%- elif access == "read" %}
                        &self.states.{{ state.use.field }},
                    {%- elif access == "write" %}
                        &mut self.states.{{ state.use.field }},
                    {%- else %}
                        todo!("Invalid state use in ECS construction"),
                    {%- endif %}
                {%- endfor %}
            )
            .inspect_err(|error| tracing::error!(%error, "{{ system.name.type }}::on_begin_phase returned an error"))
            .is_ok();
        {%- endfor %}

        {
            // TODO: Skip spawning thread here when there is only one system, or when all run in sequence
            rayon::scope(|s| {
                // TODO: Instead of parallelizing systems (and then have them access archetypes), parallelize archetypes and apply all systems. This should improve data parallelism because it keeps caches hot.
                {%- for system in group %}
                if is_{{ system.name.field }}_ready {
                    s.spawn(|_| {
                        // Preflight
                        {
                            {%- if system.preflight %}
                            {%- for archetype in system.affected_archetypes %}
                            // Preflight of {{ system.name.type }} for {{ archetype.type }}
                            self.systems.{{ system.name.field }}.preflight(
                                {%- if system.needs_context %}
                                &self.context,
                                {%- endif %}
                                {%- if (system.lookup | count) > 0 %}
                                Box::new(&self.archetypes),
                                {%- endif -%}
                                {%- for state in system.states %}
                                    {%- set access = state.preflight | default(value="none") %}
                                    {%- if access == "none" %}
                                        {# skip #}
                                    {%- elif access == "read" %}
                                        &self.states.{{ state.use.field }},
                                    {%- elif access == "write" %}
                                        &mut self.states.{{ state.use.field }},
                                    {%- else %}
                                        todo!("Invalid state use in ECS construction"),
                                    {%- endif %}
                                {%- endfor %}
                                {%- if system.needs_entities %}
                                &self.archetypes.collection.{{ archetype.field }}.entities,
                                {%- endif %}
                                {%- for input in system.inputs %}
                                &self.archetypes.collection.{{ archetype.field }}.{{ input.fields }},
                                {%- endfor %}
                                {%- for output in system.outputs %}
                                &self.archetypes.collection.{{ archetype.field }}.{{ output.fields }},
                                {%- endfor %}
                                {%- if system.emits_commands %}
                                &self.command_queue
                                {%- endif %}
                            );
                            {%- endfor %}
                            {%- else %}
                            // System has no preflight step
                            {%- endif %}
                        }

                        // Systems
                        {
                            {%- if system.needs_entities %}
                            let entities: [&[::sillyecs::EntityId]; {{ system.affected_archetypes | length }}] = [
                                {%- for archetype in system.affected_archetypes %}
                                &self.archetypes.collection.{{ archetype.field }}.entities,
                                {%- endfor %}
                            ];
                            {%- endif %}
                            {%- for input in system.inputs %}
                            let {{ input.field }}_inputs: [&[{{ input.type }}]; {{ system.affected_archetypes | length }}] = [
                                {%- for archetype in system.affected_archetypes %}
                                &self.archetypes.collection.{{ archetype.field }}.{{ input.fields }},
                                {%- endfor %}
                            ];
                            {%- endfor %}
                            {%- for output in system.outputs %}
                            let {{ output.field }}_outputs: [&mut [{{ output.type }}]; {{ system.affected_archetypes | length }}] = [
                                {%- for archetype in system.affected_archetypes %}
                                &mut self.archetypes.collection.{{ archetype.field }}.{{ output.fields }},
                                {%- endfor %}
                            ];
                            {%- endfor %}

                            // Apply {{ system.name.type }} to all archetypes
                            self.systems.{{ system.name.field }}.apply_all(
                                {%- if system.needs_context %}
                                &self.context,
                                {%- endif %}
                                {%- for state in system.states %}
                                    {%- set access = state.system | default(value="none") %}
                                    {%- if access == "none" %}
                                        {# skip #}
                                    {%- elif access == "read" %}
                                        &self.states.{{ state.use.field }},
                                    {%- elif access == "write" %}
                                        &mut self.states.{{ state.use.field }},
                                    {%- else %}
                                        todo!("Invalid state use in ECS construction"),
                                    {%- endif %}
                                {%- endfor %}
                                {%- if system.needs_entities %}
                                entities,
                                {%- endif %}
                                {%- for input in system.inputs %}
                                {{ input.field }}_inputs,
                                {%- endfor %}
                                {%- for output in system.outputs %}
                                {{ output.field }}_outputs,
                                {%- endfor %}
                                {%- if system.emits_commands %}
                                &self.command_queue
                                {%- endif %}
                            );
                        }

                        // Postflight
                        {
                            {%- if system.postflight %}
                            {%- for archetype in system.affected_archetypes %}
                            // Postflight of {{ system.name.type }} for {{ archetype.type }}
                            self.systems.{{ system.name.field }}.postflight(
                                {%- if system.needs_context %}
                                &self.context,
                                {%- endif %}
                                {%- if (system.lookup | count) > 0 %}
                                Box::new(&self.archetypes),
                                {%- endif -%}
                                {%- for state in system.states %}
                                    {%- set access = state.postflight | default(value="none") %}
                                    {%- if access == "none" %}
                                        {# skip #}
                                    {%- elif access == "read" %}
                                        &self.states.{{ state.use.field }},
                                    {%- elif access == "write" %}
                                        &mut self.states.{{ state.use.field }},
                                    {%- else %}
                                        todo!("Invalid state use in ECS construction"),
                                    {%- endif %}
                                {%- endfor %}
                                {%- if system.needs_entities %}
                                &self.archetypes.collection.{{ archetype.field }}.entities,
                                {%- endif %}
                                {%- for input in system.inputs %}
                                &self.archetypes.collection.{{ archetype.field }}.{{ input.fields }},
                                {%- endfor %}
                                {%- for output in system.outputs %}
                                &self.archetypes.collection.{{ archetype.field }}.{{ output.fields }},
                                {%- endfor %}
                                {%- if system.emits_commands %}
                                &self.command_queue
                                {%- endif %}
                            );
                            {%- endfor %}
                            {%- else %}
                            // System has no preflight step
                            {%- endif %}
                        }
                    });
                }
                {%- endfor %}
            });
        }
        {%- for system in group %}

        self.systems.{{ system.name.field }}.on_end_phase(
            {%- if system.needs_context %}
            &self.context,
            {%- endif %}
            {%- for state in system.states %}
                {%- set access = state.end_phase | default(value="none") %}
                {%- if access == "none" %}
                    {# skip #}
                {%- elif access == "read" %}
                    &self.states.{{ state.use.field }},
                {%- elif access == "write" %}
                    &mut self.states.{{ state.use.field }},
                {%- else %}
                    todo!("Invalid state use in ECS construction"),
                {%- endif %}
            {%- endfor %}
        )
        .inspect_err(|error| tracing::error!(%error, "{{ system.name.type }}::on_end_phase returned an error"))
        .ok();
        {%- endfor %}

        {%- endfor %}
        {%- endif %}

        System{{ phase.name.type }}Events::on_end_phase(
            &mut self.events,
            result,
            &self.context,
            {%- for state in phase.states %}
                {%- set access = state.end_phase | default(value="none") %}
                {%- if access == "none" %}
                    {# skip #}
                {%- elif access == "read" %}
                    &self.states.{{ state.use.field }},
                {%- elif access == "write" %}
                    &mut self.states.{{ state.use.field }},
                {%- else %}
                    todo!("Invalid state use in ECS construction"),
                {%- endif %}
            {%- endfor %}
        )
        .inspect_err(|error| tracing::error!(%error, "Failed to handle phase end events"))
        .ok();

        // Process all commands.
        self.handle_commands();
        self.on_end_{{ phase.name.field }}_phase();
    }
    {%- endfor %}

    /// Sends a command.
    ///
    /// Note that commands are picked up before and after simulation phases (not between system runs).
    /// As a result, issuing commands from the outside world will not have any effect until the next
    /// ECS phase run is executed.
    #[inline]
    pub fn command(&mut self, command: WorldCommand<Q::UserCommand>) -> Result<(), Q::Error>
    where
        Q: WorldCommandSender
    {
        self.command_queue.send(command)
    }

    /// Handles all queued commands.
    fn handle_commands(&mut self)
    where
        Q: WorldCommandReceiver
    {
        loop {
            match self.command_queue.recv() {
                Ok(Some(cmd)) => {
                    match cmd {
                        WorldCommand::SpawnEntity(data) => self.handle_spawn_command(data),
                        WorldCommand::DespawnEntity(id) => self.handle_despawn_command(id).expect("Failed to despawn"),
                        WorldCommand::User(cmd) => self.handle_user_command(cmd),
                    }
                }
                Ok(None) => break,
                Err(error) => {
                    // TODO: Make logging configurable.
                    tracing::error!(?error, "Failed to dequeue world command");
                    break;
                }
            }
        }
    }

    #[inline]
    fn handle_user_command(&mut self, data: <Q as WorldUserCommand>::UserCommand)
    where
        Q: WorldCommandReceiver,
        Self: WorldUserCommandHandler<UserCommand = <Q as WorldUserCommand>::UserCommand>
    {
        WorldUserCommandHandler::handle_user_command(self, data);
    }

    fn handle_spawn_command(&mut self, data: ArchetypeEntityData) {
        match data {
            // Accept only archetypes known to the world
            {%- for archetype in world.archetypes %}
            ArchetypeEntityData::{{ archetype.name.raw }}(data) => {
                let id = self.spawn_{{ archetype.name.field }}(data);
                tracing::trace!(%id, "Spawned {{ archetype.name.raw }} entity");
            },
            {%- endfor %}
            // TODO: Make it a non-panic on release builds?
            #[allow(unreachable_patterns)]
            unhandled => panic!("Cannot spawn entity for {id} which is not known to this world.", id = unhandled.archetype_id())
        }
    }

    fn handle_despawn_command(&mut self, id: ::sillyecs::EntityId) -> Result<(), DespawnError> {
         if let Some(loc) = self.archetypes.entity_locations.remove(&id) {
            let result = match loc.archetype {
                {%- for archetype in world.archetypes %}
                {{ archetype.name.type }}::ID => {
                    self.archetypes
                        .collection
                        .{{ archetype.name.field }}
                        .drop_at_index(loc.index)
                        .map_err(|index| DespawnError::InvalidIndexInArchetype(index, {{ archetype.name.type }}::ID))?
                }
                {%- endfor %}
                // TODO: Make it a non-panic on release builds?
                #[allow(unreachable_patterns)]
                archetype_id => unreachable!("Cannot remove entity {id} from archetype {archetype_id} which is not known to this world.")
            };

            if let Some(moved_entity) = result {
                self.archetypes.entity_locations.insert(moved_entity, EntityArchetypeRef {
                    archetype: loc.archetype,
                    index: loc.index
                });
            }
         } else {
            return Err(DespawnError::EntityNotFound(id));
         }
         Ok(())
    }
}
{%- endfor  %}
{%- if ecs.any_phase_fixed %}

/// Time accumulators for fixed-time phases.
#[derive(Debug, Clone, Default)]
struct FixedAccumulators {
    {%- for phase in ecs.phases %}
    {%- if phase.fixed %}
    /// The time accumulator for the [`{{ phase.name.raw }}`](SystemPhase::{{ phase.name.raw }}) fixed-time step.
    {{ phase.name.field }}: f32,
    {%- endif %}
    {%- endfor %}
}
{%- endif %}
/// Delta time trackers for all phases.
#[derive(Debug, Clone)]
struct DeltaTimers {
    {%- for phase in ecs.phases %}
    /// The current start time for the [`{{ phase.name.raw }}`]({{ phase.name.type }}) phase.
    current_{{ phase.name.field }}_start: std::time::Instant,
    /// The previous start time for the [`{{ phase.name.raw }}`]({{ phase.name.type }}) phase.
    previous_{{ phase.name.field }}_start: std::time::Instant,
    {%- endfor %}
}

impl Default for DeltaTimers {
    fn default() -> Self {
        let now = std::time::Instant::now();
        Self {
            {%- for phase in ecs.phases %}
            current_{{ phase.name.field }}_start: now,
            previous_{{ phase.name.field }}_start: now,
            {%- endfor %}
        }
    }
}

#[derive(Debug)]
pub enum DespawnError {
    EntityNotFound(::sillyecs::EntityId),
    InvalidIndexInArchetype(usize, ArchetypeId)
}

impl core::fmt::Display for DespawnError {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> Result<(), core::fmt::Error> {
        match self {
            Self::EntityNotFound(id) => {
                write!(f, "Failed to despawn unknown entity {id}")
            }
            Self::InvalidIndexInArchetype(index, aid) => {
                write!(f, "Failed to despawn entity at invalid index {index} in archetype {aid}")
            }
        }
    }
}
impl core::error::Error for DespawnError { }
{%- for world in ecs.worlds %}

impl<E, Q> {{ world.name.type }}<E, Q> {
    /// Frontloads entities provided by their archetype IDs and indexes (e.g., from quadtree results,
    /// followed by entity location lookups). Performs best when the indices are presorted in ascending order.
    ///
    /// Returns the count of frontloaded entities.
    #[allow(dead_code)]
    pub fn frontload(
        &mut self,
        archetype: ArchetypeId,
        indices_to_frontload: &[usize],
        previous_frontload_pivot: Option<usize>
    ) -> usize {
        match archetype {
            {%- for archetype in world.archetypes %}
            ArchetypeId::{{ archetype.name.raw }} => {
                self.frontload_{{ archetype.name.fields }}_by_indices_sorted(
                    indices_to_frontload,
                    previous_frontload_pivot
                )
            },
            {%- endfor %}
            #[allow(unreachable_patterns)]
            _ => {
                0
            }
        }
    }

{%- for archetype in world.archetypes %}

    /// Frontloads entities provided by their IDs (e.g., from quadtree results).
    /// Returns the count of frontloaded entities.
    #[inline(always)]
    #[allow(dead_code)]
    pub fn frontload_{{ archetype.name.fields }}(
        &mut self,
        entities_to_frontload: &[::sillyecs::EntityId],
        previous_frontload_pivot: Option<usize>
    ) -> usize {
        self.archetypes
            .collection
            .{{ archetype.name.field }}
            .frontload(
                &mut self.archetypes.entity_locations,
                entities_to_frontload,
                previous_frontload_pivot
            )
    }

    /// Frontloads entities provided by their IDs (e.g., from quadtree results).
    ///
    /// This function operates directly on indices and assumes that the index list is sorted
    /// for coherent cache access. It works with unsorted lists but may have degraded performance.
    ///
    /// Returns the count of frontloaded entities.
    #[inline(always)]
    #[allow(dead_code)]
    pub fn frontload_{{ archetype.name.fields }}_by_indices_sorted<I>(
        &mut self,
        indices_to_frontload: I,
        previous_frontload_pivot: Option<usize>
    ) -> usize
    where
        I: AsRef<[usize]>
    {
        self.archetypes
            .collection
            .{{ archetype.name.field }}
            .frontload_by_indices_sorted(
                &mut self.archetypes.entity_locations,
                indices_to_frontload,
                previous_frontload_pivot
            )
    }

    /// Frontloads entities satisfying `should_frontload`.
    /// Returns the number of entities frontloaded.
    #[inline(always)]
    #[allow(dead_code)]
    pub fn frontload_{{ archetype.name.fields }}_by_scan<F>(
        &mut self,
        should_frontload: F,
    ) -> usize
    where
        for<'archetype> F: FnMut(&{{ archetype.name.raw }}EntityRef<'archetype>) -> bool,
    {
        self.archetypes
            .collection
            .{{ archetype.name.field }}
            .frontload_scan(
                &mut self.archetypes.entity_locations,
                should_frontload
            )
    }
{%- endfor %}
}
{%- endfor %}

pub trait ComponentAccess {
    {%- for component in ecs.components %}

    /// Gets the [`{{component.name.raw}}`]({{component.name.type}}) component of the specified entity.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{component.name.field}}_component(&self, entity_id: ::sillyecs::EntityId) -> Option<&{{component.name.type}}> {
        None
    }
    {%- endfor %}
}

pub trait ComponentAccessMut: ComponentAccess {
    {%- for component in ecs.components %}

    /// Mutably gets the [`{{component.name.raw}}`]({{component.name.type}}) component of the specified entity.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{component.name.field}}_component_mut(&mut self, entity_id: ::sillyecs::EntityId) -> Option<&mut {{component.name.type}}> {
        None
    }
    {%- endfor %}
}

pub trait EntityAccess {
    {%- for archetype in ecs.archetypes %}

    /// Accesses the `{{ archetype.name.raw }}` entity with the given ID if it exists in this archetype.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{ archetype.name.field }}_entity(
        &self,
        entity_id: ::sillyecs::EntityId
    ) -> Option<{{ archetype.name.raw }}EntityRef>
    {
        None
    }
    {%- endfor %}
}

pub trait EntityAccessMut: EntityAccess {
    {%- for archetype in ecs.archetypes %}

    /// Mutably accesses the `{{ archetype.name.raw }}` entity with the given ID if it exists in this archetype.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{ archetype.name.field }}_entity_mut(
        &mut self,
        entity_id: ::sillyecs::EntityId
    ) -> Option<{{ archetype.name.raw }}EntityMut>
    {
        None
    }
    {%- endfor %}
}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl<E, Q> EntityAccess for {{ world.name.type }}<E, Q> {
    {%- for archetype in world.archetypes %}

    /// Accesses the `{{ archetype.name.raw }}` entity with the given ID if it exists in this archetype.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{ archetype.name.field }}_entity(
        &self,
        entity_id: ::sillyecs::EntityId
    ) -> Option<{{ archetype.name.raw }}EntityRef>
    {
        EntityAccess::get_{{ archetype.name.field }}_entity(&self.archetypes, entity_id)
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl<E, Q> EntityAccessMut for {{ world.name.type }}<E, Q> {
    {%- for archetype in world.archetypes %}

    /// Mutably accesses the `{{ archetype.name.raw }}` entity with the given ID if it exists in this archetype.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{ archetype.name.field }}_entity_mut(
        &mut self,
        entity_id: ::sillyecs::EntityId
    ) -> Option<{{ archetype.name.raw }}EntityMut>
    {
        EntityAccessMut::get_{{ archetype.name.field }}_entity_mut(&mut self.archetypes, entity_id)
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl<E, Q> ComponentAccess for {{ world.name.type }}<E, Q> {
    {%- for component in world.components %}

    /// Gets the [`{{component.raw}}`]({{component.type}}) component of the specified entity.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{component.field}}_component(&self, entity_id: ::sillyecs::EntityId) -> Option<&{{component.type}}> {
        ComponentAccess::get_{{component.field}}_component(&self.archetypes, entity_id)
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl<E, Q> ComponentAccessMut for {{ world.name.type }}<E, Q> {
    {%- for component in world.components %}

    /// Mutably gets the [`{{component.raw}}`]({{component.type}}) component of the specified entity.
    #[allow(dead_code, unused)]
    #[inline]
    fn get_{{component.field}}_component_mut(&mut self, entity_id: ::sillyecs::EntityId) -> Option<&mut {{component.type}}> {
        ComponentAccessMut::get_{{component.field}}_component_mut(&mut self.archetypes, entity_id)
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl EntityAccess for {{ world.name.type }}Archetypes {
    {%- for archetype in world.archetypes %}

    /// Accesses the `{{ archetype.name.raw }}` entity with the given ID if it exists in this archetype.
    #[allow(dead_code, unused)]
    fn get_{{ archetype.name.field }}_entity(
        &self,
        entity_id: ::sillyecs::EntityId
    ) -> Option<{{ archetype.name.raw }}EntityRef>
    {
        let ear = self.entity_locations.get(&entity_id)?.clone();
        if ear.archetype != {{ archetype.name.type }}::ID {
            return None;
        }
        self.collection
            .{{ archetype.name.field }}
            .get_entity_at(ear.index)
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl EntityAccessMut for {{ world.name.type }}Archetypes {
    {%- for archetype in world.archetypes %}

    /// Mutably accesses the `{{ archetype.name.raw }}` entity with the given ID if it exists in this archetype.
    #[allow(dead_code, unused)]
    fn get_{{ archetype.name.field }}_entity_mut(
        &mut self,
        entity_id: ::sillyecs::EntityId
    ) -> Option<{{ archetype.name.raw }}EntityMut>
    {
        let ear = self.entity_locations.get(&entity_id)?.clone();
        if ear.archetype != {{ archetype.name.type }}::ID {
            return None;
        }
        self.collection
            .{{ archetype.name.field }}
            .get_entity_at_mut(ear.index)
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl ComponentAccess for {{ world.name.type }}Archetypes {
    {%- for component, archetypes in world.components|items %}

    /// Gets the `{{component.raw}}` component of the specified entity.
    #[allow(dead_code)]
    fn get_{{component.field}}_component(&self, entity_id: ::sillyecs::EntityId) -> Option<&{{component.type}}> {
        let ear = self.entity_locations.get(&entity_id)?.clone();
        match ear.archetype {
            {%- for archetype in archetypes %}
            {{ archetype.type }}::ID => self.collection.{{ archetype.field }}.get_{{component.field}}_component_at(ear.index),
            {%- endfor %}
            #[allow(dead_code)]
            _ => None
        }
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

//noinspection RsSortImplTraitMembers
impl ComponentAccessMut for {{ world.name.type }}Archetypes {
    {%- for component, archetypes in world.components|items %}

    /// Mutably gets the `{{component.raw}}` component of the specified entity.
    #[allow(dead_code)]
    fn get_{{component.field}}_component_mut(&mut self, entity_id: ::sillyecs::EntityId) -> Option<&mut {{component.type}}> {
        let ear = self.entity_locations.get(&entity_id)?.clone();
        match ear.archetype {
            {%- for archetype in archetypes %}
            {{ archetype.type }}::ID => self.collection.{{ archetype.field }}.get_{{component.field}}_component_at_mut(ear.index),
            {%- endfor %}
            #[allow(dead_code)]
            _ => None
        }
    }
    {%- endfor %}
}
{%- endfor %}
{%- for world in ecs.worlds %}

impl<E, Q, U> WorldUserCommand for {{ world.name.type }}<E, Q>
where
    Q: WorldUserCommand<UserCommand = U>,
    U: core::marker::Send + core::fmt::Debug
{
    type UserCommand = U;
}
{%- endfor %}

/// An iterator over [`EntityId`](::sillyecs::EntityId) values.
#[allow(dead_code)]
pub type EntityIdIter<'a> = ::sillyecs::FlattenCopySlices<'a, ::sillyecs::EntityId>;
{%- for component in ecs.components %}

/// An iterator over all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
#[allow(dead_code)]
// TODO: Simplify to ::core::slice::Iter<> if only one archetype has this component.
pub type {{ component.name.raw }}ComponentIter<'a> = ::sillyecs::FlattenSlices<'a, {{ component.name.type }}>;

/// A mutable iterator over all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
#[allow(dead_code)]
// TODO: Simplify to ::core::slice::IterMut<> if only one archetype has this component.
pub type {{ component.name.raw }}ComponentIterMut<'a> = ::sillyecs::FlattenSlicesMut<'a, {{ component.name.type }}>;

/// A trait for types allowing to iterate all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
#[allow(dead_code)]
pub trait Iter{{ component.name.raw }}Components<'a> {
    type Iterator: core::iter::Iterator<Item = &'a {{ component.name.type }}>;

    /// Iterates all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
    fn iter_{{ component.name.fields }}(&'a self) -> Self::Iterator;
}

/// A trait for types allowing to iterate the [`EntityId`](::sillyecs::EntityId) values
/// of all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
#[allow(dead_code)]
pub trait Iter{{ component.name.raw }}Entities<'a> {
    type Iterator: core::iter::Iterator<Item = ::sillyecs::EntityId>;

    /// Iterates all entity IDs of [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
    fn iter_{{ component.name.field }}_entities(&'a self) -> Self::Iterator;
}

/// A trait for types allowing to iterate all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
#[allow(dead_code)]
pub trait IterMut{{ component.name.raw }}Components<'a> {
    type IteratorMut: core::iter::Iterator<Item = &'a mut {{ component.name.type }}>;

    /// Iterates all [`{{ component.name.raw }}`]({{ component.name.type }}) components, regardless of archetype.
    fn iter_{{ component.name.fields }}_mut(&'a mut self) -> Self::IteratorMut;
}
{%- endfor %}
{%- for world in ecs.worlds %}
{%- for component in world.components %}

#[allow(dead_code)]
impl<'a, E, Q> Iter{{ component.raw }}Components<'a> for {{ world.name.type }}<E, Q>
{
    type Iterator = {{ component.raw }}ComponentIter<'a>;

    /// Iterates over the [`{{ component.raw }}`]({{ component.type}}) component of the following archetypes, in that order:
    /// {%- for archetype in world.archetypes %}{% for arch_comp in archetype.components %}{% if arch_comp.type == component.type %}
    /// - [`{{archetype.name.raw}}`]({{archetype.name.type}}){% endif %}{% endfor %}{% endfor %}
    fn iter_{{ component.fields }}(&'a self) -> Self::Iterator {
        // TODO: Simplify to ::core::slice::Iter<> if only one archetype has this component.
        {{ component.raw }}ComponentIter::new([
            {%- for archetype in world.archetypes %}
            {%- for arch_comp in archetype.components %}
            {%- if arch_comp.type == component.type %}
            &self.archetypes.collection.{{archetype.name.field}}.{{ arch_comp.fields }},
            {%- endif %}
            {%- endfor %}
            {%- endfor %}
        ])
    }
}

#[allow(dead_code)]
impl<'a, E, Q> Iter{{ component.raw }}Entities<'a> for {{ world.name.type }}<E, Q>
{
    type Iterator = EntityIdIter<'a>;

    /// Iterates all entity IDs of [`{{ component.raw }}`]({{ component.type }}) components, regardless of archetype.
    fn iter_{{ component.field }}_entities(&'a self) -> Self::Iterator {
        // TODO: Simplify to ::core::slice::Iter<> if only one archetype has this component.
        EntityIdIter::new([
            {%- for archetype in world.archetypes %}
            {%- for arch_comp in archetype.components %}
            {%- if arch_comp.type == component.type %}
            &self.archetypes.collection.{{archetype.name.field}}.entities,
            {%- endif %}
            {%- endfor %}
            {%- endfor %}
        ])
    }
}

#[allow(dead_code)]
impl<'a, E, Q> IterMut{{ component.raw }}Components<'a> for {{ world.name.type }}<E, Q>
{
    type IteratorMut = {{ component.raw }}ComponentIterMut<'a>;

    /// Mutably iterates over the [`{{ component.raw }}`]({{ component.type}}) component of the following archetypes, in that order:
    /// {%- for archetype in world.archetypes %}{% for arch_comp in archetype.components %}{% if arch_comp.type == component.type %}
    /// - [`{{archetype.name.raw}}`]({{archetype.name.type}}){% endif %}{% endfor %}{% endfor %}
    fn iter_{{ component.fields }}_mut(&'a mut self) -> Self::IteratorMut {
        // TODO: Simplify to ::core::slice::Iter<> if only one archetype has this component.
        {{ component.raw }}ComponentIterMut::new([
            {%- for archetype in world.archetypes %}
            {%- for arch_comp in archetype.components %}
            {%- if arch_comp.type == component.type %}
            &mut self.archetypes.collection.{{archetype.name.field}}.{{ arch_comp.fields }},
            {%- endif %}
            {%- endfor %}
            {%- endfor %}
        ])
    }
}
{%- endfor %}
{%- endfor %}
