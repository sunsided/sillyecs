/// A world holding all archetypes.
#[derive(Debug, Clone)]
pub struct World<E = ()> {
    {%- for archetype in ecs.archetypes %}
    pub {{ archetype.name.field | snake_case }}: {{ archetype.name.type }},
    {%- endfor %}

    {%- for system in ecs.systems %}
    pub {{ system.name.field }}_system: {{ system.name.type }},
    {%- endfor %}

    /// The system phase events
    events: Option<E>
}

impl<E> World<E> {
    /// Creates a new [`World`].
    pub fn new<S>(create_systems: &S, phase_events: Option<E>) -> Self
    where
        S: CreateSystems,
        E: SystemPhaseEvents
    {
        {%- for system in ecs.systems %}
        let {{ system.name.field }}_system = create_systems.create_{{ system.name.field }}();
        {%- endfor %}
        Self {
            {%- for archetype in ecs.archetypes %}
            {{ archetype.name.field | snake_case }}: {{ archetype.name.type }}::default(),
            {%- endfor %}
            {%- for system in ecs.systems %}
            {{ system.name.field }}_system,
            {%- endfor %}
            events: phase_events
        }
    }

    /// Apply all system phases.
    pub fn apply_system_phases(&mut self)
    where
        E: SystemPhaseEvents
    {
        {%- for phase in ecs.phases %}
        self.apply_system_phase_{{ phase.name.field }}();
        {%- endfor %}
    }

    /// Apply all system phases with thread parallelism.
    pub fn par_apply_system_phases(&mut self)
    where
        E: SystemPhaseEvents
    {
        {%- for phase in ecs.phases %}
        self.par_apply_system_phase_{{ phase.name.field }}();
        {%- endfor %}
    }
    {%- for phase in ecs.phases %}

    /// Execute system phase `{{ phase.name.raw }}`
    pub fn apply_system_phase_{{ phase.name.field }}(&mut self)
    where
        E: SystemPhaseEvents
    {
        if let Some(events) = &mut self.events {
            events.on_begin_{{ phase.name.field }}_phase();
        }

        {%- if ecs.scheduled_systems[phase.name] | length == 0 %}
        // no systems in this phase
        {%- else %}
        {%- for group in ecs.scheduled_systems[phase.name] %}
        {%- set group_number = loop.index %}
        {%- for system in group %}
        {%- for archetype in system.affected_archetypes %}
        // System group {{ group_number }}: Apply {{ system.name.type }} to {{ archetype.type }}
        self.{{ system.name.field }}_system.apply_many(
            {%- for input in system.inputs %}
            &self.{{ archetype.field }}.{{ input.fields }},
            {%- endfor %}
            {%- for output in system.outputs %}
            &mut self.{{ archetype.field }}.{{ output.fields }},
            {%- endfor %}
        );
        {%- endfor %}
        {%- endfor %}
        {%- endfor %}
        {%- endif %}

        if let Some(events) = &mut self.events {
            events.on_end_{{ phase.name.field }}_phase();
        }
    }

    pub fn par_apply_system_phase_{{ phase.name.field }}(&mut self)
    where
        E: SystemPhaseEvents
    {
        if let Some(events) = &mut self.events {
            events.on_begin_{{ phase.name.field }}_phase();
        }

        {%- if ecs.scheduled_systems[phase.name] | length == 0 %}
        // no systems in this phase
        {%- else %}
        {%- for group in ecs.scheduled_systems[phase.name] %}
        {%- set group_number = loop.index %}
        // System group {{ group_number }}
        rayon::scope(|s| {
            // TODO: Instead of parallelizing systems (and then have them access archetypes), parallelize archetypes and apply all systems. This should improve data parallelism because it keeps caches hot.

            {%- for system in group %}
            s.spawn(|_| {
                {%- for archetype in system.affected_archetypes %}
                // Apply {{ system.name.type }} to {{ archetype.type }}
                self.{{ system.name.field }}_system.apply_many(
                    {%- for input in system.inputs %}
                    &self.{{ archetype.field }}.{{ input.fields }},
                    {%- endfor %}
                    {%- for output in system.outputs %}
                    &mut self.{{ archetype.field }}.{{ output.fields }},
                    {%- endfor %}
                );
            {%- endfor %}
            });
            {%- endfor %}
        });
        {%- endfor %}
        {%- endif %}

        if let Some(events) = &mut self.events {
            events.on_end_{{ phase.name.field }}_phase();
        }
    }
    {%- endfor %}
}
