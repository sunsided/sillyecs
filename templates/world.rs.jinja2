/// A frame context.
#[derive(Debug, Clone)]
#[allow(dead_code)]
pub struct FrameContext {
    /// The frame number.
    pub frame_number: u64,

    /// The start time of the last frame.
    pub last_frame_start: std::time::Instant,

    /// The delta time since the last frame.
    pub delta_time: std::time::Duration,

    /// The fixed time for fixed-time systems.
    pub fixed_time: std::time::Duration,

    /// User-specific data.
    pub data: FrameContextData
}

#[allow(dead_code)]
impl Default for FrameContext {
    fn default() -> Self {
        Self {
            frame_number: 0,
            last_frame_start: std::time::Instant::now(),
            delta_time: Default::default(),
            fixed_time: Default::default(),
            data: Default::default()
        }
    }
}

#[allow(dead_code)]
impl std::ops::Deref for FrameContext {
    type Target = FrameContextData;

    fn deref(&self) -> &Self::Target {
        &self.data
    }
}

#[allow(dead_code)]
impl std::ops::DerefMut for FrameContext {
    fn deref_mut(&mut self) -> &mut Self::Target {
        &mut self.data
    }
}

/// A world holding all archetypes.
#[derive(Debug, Clone)]
pub struct World<E = ()> {
    {%- for archetype in ecs.archetypes %}
    pub {{ archetype.name.field | snake_case }}: {{ archetype.name.type }},
    {%- endfor %}

    {%- for system in ecs.systems %}
    pub {{ system.name.field }}_system: {{ system.name.type }},
    {%- endfor %}

    /// The frame context.
    pub context: FrameContext,

    /// The system phase events
    events: Option<E>
}

#[allow(dead_code)]
impl<E> World<E> {
    /// Creates a new [`World`].
    pub fn new<S>(create_systems: &S, phase_events: Option<E>) -> Self
    where
        S: CreateSystems,
        E: SystemPhaseEvents
    {
        let context = FrameContext::default();
        {%- for system in ecs.systems %}
        let {{ system.name.field }}_system = create_systems.create_{{ system.name.field }}();
        {%- endfor %}
        Self {
            {%- for archetype in ecs.archetypes %}
            {{ archetype.name.field | snake_case }}: {{ archetype.name.type }}::default(),
            {%- endfor %}
            {%- for system in ecs.systems %}
            {{ system.name.field }}_system,
            {%- endfor %}
            context,
            events: phase_events
        }
    }

    /// Apply all system phases sequentially.
    ///
    /// This method executes all system phases in sequence.
    /// The phases are processed in the following order:
    ///
    /// {% for phase in ecs.phases %}- {{ phase.name.raw }}
    /// {% endfor %}
    /// # Type Parameters
    /// - `E`: The type implementing [`SystemPhaseEvents`] for phase lifecycle events
    pub fn apply_system_phases(&mut self)
    where
        E: SystemPhaseEvents
    {
        {%- for phase in ecs.phases %}
        self.apply_system_phase_{{ phase.name.field }}();
        {%- endfor %}
    }

    /// Apply all system phases with thread parallelism.
    ///
    /// This method executes all system phases in sequence, but with parallel execution
    /// of systems within each phase. The phases are processed in the following order:
    ///
    /// {% for phase in ecs.phases %}- {{ phase.name.raw }}
    /// {% endfor %}
    /// # Type Parameters
    /// - `E`: The type implementing [`SystemPhaseEvents`] for phase lifecycle events
    ///
    /// # Parallelism
    /// - Each phase is processed sequentially
    /// - Within each phase, systems are executed in parallel where possible
    /// - Thread parallelism is implemented using the Rayon library
    pub fn par_apply_system_phases(&mut self)
    where
        E: SystemPhaseEvents
    {
        {%- for phase in ecs.phases %}
        self.par_apply_system_phase_{{ phase.name.field }}();
        {%- endfor %}
    }
    {%- for phase in ecs.phases %}

    /// Execute system phase `{{ phase.name.raw }}`
    ///
    /// This method executes all systems scheduled for the `{{ phase.name.raw }}` phase in sequential order.
    /// Systems are organized into groups that must be executed in sequence, while systems within each
    /// group can potentially be parallelized (see `par_apply_system_phase_{{ phase.name.field }}`).
    ///
    /// # Execution Flow
    /// 1. Triggers the phase start event if event handling is enabled
    /// 2. Sequentially processes each system group
    /// 3. For each system in a group:
    ///    - Applies the system to all matching archetypes
    ///    - Provides read-only access to input components
    ///    - Provides mutable access to output components
    /// 4. Triggers the phase end event if event handling is enabled
    ///
    /// # Type Parameters
    /// - `E`: The type implementing `SystemPhaseEvents` for phase lifecycle events
    fn apply_system_phase_{{ phase.name.field }}(&mut self)
    where
        E: SystemPhaseEvents
    {
        if let Some(events) = &mut self.events {
            events.on_begin_phase(SystemPhase::{{ phase.name.raw }});
        }

        {%- if ecs.scheduled_systems[phase.name] | length == 0 %}
        // no systems in this phase
        {%- else %}
        {%- for group in ecs.scheduled_systems[phase.name] %}
        {%- set group_number = loop.index %}
        {%- for system in group %}
        {%- for archetype in system.affected_archetypes %}
        // System group {{ group_number }}: Apply {{ system.name.type }} to {{ archetype.type }}
        self.{{ system.name.field }}_system.apply_many(
            {%- if system.needs_context %}
            &self.context,
            {%- endif %}
            {%- if system.needs_entities %}
            &self.{{ archetype.field }}.entities,
            {%- endif %}
            {%- for input in system.inputs %}
            &self.{{ archetype.field }}.{{ input.fields }},
            {%- endfor %}
            {%- for output in system.outputs %}
            &mut self.{{ archetype.field }}.{{ output.fields }},
            {%- endfor %}
        );
        {%- endfor %}
        {%- endfor %}
        {%- endfor %}
        {%- endif %}

        if let Some(events) = &mut self.events {
            events.on_end_phase(SystemPhase::{{ phase.name.raw }});
        }
    }

    /// Applies the specified system phase with parallel execution of systems.
    ///
    /// This method uses Rayon's parallel scoping to execute systems concurrently within each system
    /// group. Systems within a group are executed in parallel while groups themselves are processed
    /// sequentially.
    ///
    /// # Type Parameters
    /// - `E`: The type implementing `SystemPhaseEvents` for phase lifecycle events
    ///
    /// # Notes
    /// - Systems in each group are spawned as parallel tasks
    /// - Each system operates on its affected archetypes concurrently
    /// - Phase events are triggered at the start and end of execution
    fn par_apply_system_phase_{{ phase.name.field }}(&mut self)
    where
        E: SystemPhaseEvents
    {
        if let Some(events) = &mut self.events {
            events.on_begin_phase(SystemPhase::{{ phase.name.raw }});
        }

        {%- if ecs.scheduled_systems[phase.name] | length == 0 %}
        // no systems in this phase
        {%- else %}
        {%- for group in ecs.scheduled_systems[phase.name] %}
        {%- set group_number = loop.index %}
        // System group {{ group_number }}
        rayon::scope(|s| {
            // TODO: Instead of parallelizing systems (and then have them access archetypes), parallelize archetypes and apply all systems. This should improve data parallelism because it keeps caches hot.

            {%- for system in group %}
            s.spawn(|_| {
                {%- for archetype in system.affected_archetypes %}
                // Apply {{ system.name.type }} to {{ archetype.type }}
                self.{{ system.name.field }}_system.apply_many(
                    {%- if system.needs_context %}
                    &self.context,
                    {%- endif %}
                    {%- if system.needs_entities %}
                    &self.{{ archetype.field }}.entities,
                    {%- endif %}
                    {%- for input in system.inputs %}
                    &self.{{ archetype.field }}.{{ input.fields }},
                    {%- endfor %}
                    {%- for output in system.outputs %}
                    &mut self.{{ archetype.field }}.{{ output.fields }},
                    {%- endfor %}
                );
            {%- endfor %}
            });
            {%- endfor %}
        });
        {%- endfor %}
        {%- endif %}

        if let Some(events) = &mut self.events {
            events.on_end_phase(SystemPhase::{{ phase.name.raw }});
        }
    }
    {%- endfor %}
}
